import{_ as i,c as a,a as n,o as e}from"./app-2v4np_wx.js";const l="/assets/7f8552320298454a8d0f9a3c309ff37b-DltVy1LQ.png",t={};function d(h,s){return e(),a("div",null,s[0]||(s[0]=[n('<h2 id="redisson-watchdog机制" tabindex="-1"><a class="header-anchor" href="#redisson-watchdog机制"><span>Redisson -WatchDog机制<img src="'+l+`" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></span></a></h2><h3 id="_1-watchdog-的背景和作用" tabindex="-1"><a class="header-anchor" href="#_1-watchdog-的背景和作用"><span><strong>1. Watchdog 的背景和作用</strong></span></a></h3><p>在分布式系统中，分布式锁通常使用 Redis 的 <code>SET</code> 命令实现，其中带有一个过期时间（<code>TTL</code>）来防止因锁未释放而导致的死锁问题。然而，在某些情况下：</p><ul><li>业务逻辑执行时间可能超过了锁的默认过期时间（<code>TTL</code>）。</li><li>如果没有扩展锁的时间，锁会自动过期并释放，导致其他线程获得锁，进而引发数据一致性问题。</li></ul><p><strong>Watchdog 的作用</strong>就是动态续约锁的过期时间，确保锁在持有者未主动释放之前不会被其他线程获取。</p><hr><h3 id="_2-watchdog-的工作原理" tabindex="-1"><a class="header-anchor" href="#_2-watchdog-的工作原理"><span><strong>2. Watchdog 的工作原理</strong></span></a></h3><p>Redisson 默认在分布式锁中启用了 <code>watchdog</code>，其核心机制是通过定期检查锁的状态并动态更新锁的过期时间来实现锁续约。</p><h4 id="主要步骤" tabindex="-1"><a class="header-anchor" href="#主要步骤"><span><strong>主要步骤：</strong></span></a></h4><ol><li><strong>锁的初始化与默认过期时间</strong> 当一个线程尝试获取锁时，Redisson 会向 Redis 发送一个带有默认过期时间（<code>TTL</code>）的锁命令。 <ul><li>默认 <code>TTL</code> 时间为 <strong>30秒</strong>。</li><li>这个时间可以通过配置修改，也可以手动设置自定义过期时间。</li></ul></li><li><strong>Watchdog 自动续约</strong> 一旦锁被获取，Redisson 会启动一个 <strong>Watchdog 定时任务</strong>，每隔一段时间（通常是 10 秒）检查锁是否仍然被持有，并自动将锁的过期时间续约到默认的 <code>TTL</code>（30秒）。 <ul><li>如果业务逻辑没有完成，Watchdog 会持续续约。</li><li>如果锁已经被主动释放，Watchdog 会停止工作。</li></ul></li><li><strong>锁的释放</strong> 当持有者线程完成任务后，Redisson 会主动调用 <code>unlock</code> 方法释放锁，并停止 Watchdog 定时任务。</li></ol><hr><h3 id="_3-watchdog-的特点" tabindex="-1"><a class="header-anchor" href="#_3-watchdog-的特点"><span><strong>3. Watchdog 的特点</strong></span></a></h3><ol><li><strong>动态续约：</strong> Watchdog 的核心是动态续约机制，它能够根据业务逻辑执行的实际时间延长锁的生命周期，避免锁意外过期。</li><li><strong>适用场景：</strong><ul><li>Watchdog 特别适合那些无法准确预估任务执行时间的场景。</li><li>如果任务可以明确估算完成时间，则可以直接设置一个合理的固定锁过期时间而不依赖 Watchdog。</li></ul></li><li><strong>默认开启：</strong> Watchdog 在 Redisson 中是默认启用的，无需显式配置，但可以根据需要调整相关参数。</li></ol><hr><h3 id="_4-相关配置" tabindex="-1"><a class="header-anchor" href="#_4-相关配置"><span><strong>4. 相关配置</strong></span></a></h3><p>Redisson 的 <code>watchdog</code> 行为可以通过配置进行调整，主要包括以下几个参数：</p><h4 id="常用配置项" tabindex="-1"><a class="header-anchor" href="#常用配置项"><span><strong>常用配置项：</strong></span></a></h4><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>singleServerConfig:</span></span>
<span class="line"><span>  idleConnectionTimeout: 10000    # 空闲连接超时时间</span></span>
<span class="line"><span>  connectTimeout: 10000           # Redis 连接超时时间</span></span>
<span class="line"><span>  timeout: 3000                   # 命令等待超时时间</span></span>
<span class="line"><span>  retryAttempts: 3                # 命令失败后重试次数</span></span>
<span class="line"><span>  retryInterval: 1500             # 命令失败后重试间隔</span></span>
<span class="line"><span>  lockWatchdogTimeout: 30000      # Watchdog 默认锁超时时间（单位：毫秒）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="参数说明" tabindex="-1"><a class="header-anchor" href="#参数说明"><span><strong>参数说明：</strong></span></a></h4><ul><li><code>lockWatchdogTimeout</code><ul><li>默认值：<code>30000</code> 毫秒（即 30 秒）。</li><li>该值决定了 Watchdog 为锁续约的时间间隔。</li></ul></li></ul><hr><h3 id="_5-watchdog-的工作机制示例" tabindex="-1"><a class="header-anchor" href="#_5-watchdog-的工作机制示例"><span><strong>5. Watchdog 的工作机制示例</strong></span></a></h3><p>假设某个线程 <code>A</code> 使用 Redisson 分布式锁实现如下逻辑：</p><h4 id="伪代码" tabindex="-1"><a class="header-anchor" href="#伪代码"><span><strong>伪代码：</strong></span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">RLock</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> redissonClient</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getLock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">myLock</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 获取锁</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">tryLock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">())</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    try</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        // 执行业务逻辑，耗时较长</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        Thread</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">sleep</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">60000</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 模拟 60 秒的耗时操作</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> finally</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">        // 释放锁</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">        lock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">unlock</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="watchdog-续约流程" tabindex="-1"><a class="header-anchor" href="#watchdog-续约流程"><span><strong>Watchdog 续约流程：</strong></span></a></h4><ol><li>线程 <code>A</code> 成功获取锁，Redis 中的 <code>myLock</code> 的初始 TTL 为 30 秒。</li><li>如果业务逻辑未完成，Redisson 内部的 Watchdog 每隔 10 秒续约一次，将锁的 TTL 延长至 30 秒。</li><li>当线程 <code>A</code> 完成任务并调用 <code>unlock</code> 方法后，锁会立即释放，Watchdog 停止工作。</li></ol><hr><h3 id="_6-watchdog-的优势" tabindex="-1"><a class="header-anchor" href="#_6-watchdog-的优势"><span><strong>6. Watchdog 的优势</strong></span></a></h3><ul><li><strong>解决锁过期问题：</strong> 避免在长时间任务场景中因锁过期导致锁被误释放。</li><li><strong>简单易用：</strong> 无需开发者手动管理锁的续约逻辑。</li><li><strong>高效可靠：</strong> 仅当锁被持有时，Watchdog 才会执行续约操作，不会额外消耗资源。</li></ul><hr><h3 id="_7-注意事项" tabindex="-1"><a class="header-anchor" href="#_7-注意事项"><span><strong>7. 注意事项</strong></span></a></h3><ol><li><strong>锁释放时机：</strong><ul><li>如果某个任务因异常未调用 <code>unlock</code>，Watchdog 会持续续约锁，可能导致锁被长期持有。因此，务必在 <code>try-finally</code> 块中释放锁。</li></ul></li><li><strong>合理配置 TTL：</strong><ul><li>对于短时间任务，可以禁用 Watchdog 并设置一个固定的锁过期时间，以减少额外的资源消耗。</li></ul></li><li><strong>集群模式兼容性：</strong><ul><li>Watchdog 在 Redis 集群模式中同样适用，因为它的续约逻辑基于 Redis 的键过期机制。</li></ul></li></ol>`,33)]))}const r=i(t,[["render",d],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/article/xht68izq/","title":"Redisson-WatchDog机制","lang":"zh-CN","frontmatter":{"title":"Redisson-WatchDog机制","tags":["Redis","锁机制"],"createTime":"2025/02/12 09:52:37","permalink":"/article/xht68izq/"},"headers":[],"readingTime":{"minutes":3.72,"words":1117},"git":{},"filePathRelative":"Redis/Redisson-WatchDog机制.md","categoryList":[{"id":"e11144","sort":10000,"name":"Redis"}]}');export{r as comp,c as data};
